@page "/comment"
@inject HttpClient Http
@inject StateContainer StateContainer

<div class="saveCommentWrapper">
    <MudButton Variant="Variant.Filled" Color="Color.Primary">сохранить комментарий</MudButton>
</div>
<MudPaper Class="innerPageWrapper">
    <div class="pageWrapper">
        <MudText Typo="Typo.h5">
            Добавить комментарий
        </MudText>

        <MudPaper>
            <MudTextField T="string" Label="Текст комментария" Variant="Variant.Text" Text="@commentText" Lines="7" />
        </MudPaper>
    </div>
</MudPaper>

<style>
    .saveCommentWrapper {
        position: absolute;
        right: 1.2rem;
        top: 2.5rem;
    }
</style>

@code {
    public string commentText = "";
    public ConsultanceCommentDto comment;

    protected override async Task OnInitializedAsync()
    {
        comment = await GetOrSetComment(StateContainer.CurrentPatient.PersonID, Guid.Empty, "");
        commentText = comment.ClientComment;
    }

    //Если consultanceId  пустой (Guid.Empty) но personId заполнен то мы просто выводим последний написанный камент, если наоборот тогда камент отправляем
    private async Task<ConsultanceCommentDto> GetOrSetComment(Guid personId, Guid consultanceId, string clientComment)
    {
        ConsultanceCommentDto result = null;
        try
        {
            var httpRequest = new HttpRequestMessage(HttpMethod.Get, "Tools/Comment");
            httpRequest.Headers.Add("consultanceId", consultanceId.ToString());
            httpRequest.Headers.Add("personId", personId.ToString());
            httpRequest.Headers.Add("clientComment", clientComment);
            HttpResponseMessage httpResponse = await Http.SendAsync(httpRequest);
            result = await httpResponse.Content.ReadFromJsonAsync<ConsultanceCommentDto>();
        }
        catch (Exception ex)
        {

        }

        return result;
    }
}
